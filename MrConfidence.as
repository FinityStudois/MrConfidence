package  {	import flash.display.*;	import flash.events.*;	import flash.text.*;	import flash.utils.Timer;	import flash.utils.getDefinitionByName;	import flash.utils.setTimeout;		import cisc60.game.character.Hero;	import cisc60.game.map.DesertMap;	import cisc60.game.map.Floor;			 [SWF(width="700", height="400", backgroundColor="#ffffff", frameRate="30")]		public class MrConfidence extends MovieClip {		var hero:Hero;		var desert_map:DesertMap;		var floor:Floor;		const speed:int = 5;  //Number of pixels character is moved on each KEY_DOWN		const spawnRate:int = 5;		var nextEnemy:Timer;		var enemies:Array = new Array();		var bullets:Array = new Array();							/*Game constructor -- For now, all it does is create an instance of a hero, set it to the 		bottom left of the screen, and adds a listener for keyboard input*/		public function MrConfidence() {			trace("before new hero");			hero = new Hero(350,385, this.bullets);			this.hero.set_speed(4);						this.desert_map = new DesertMap();			this.desert_map.x = 0;			this.desert_map.y = 400;						floor = new Floor();			floor.x = -10;			floor.y = 480;						trace("before add child(hero)");			addChild(desert_map);			addChild(floor);			addChild(hero);						stage.addEventListener(KeyboardEvent.KEY_DOWN, key_down);			addEventListener(Event.ENTER_FRAME, spawnEnemy);			addEventListener(Event.ENTER_FRAME, detectCollision);			addEventListener(Event.ENTER_FRAME, removeBullet);			//stage.addEventListener(KeyboardEvent.KEY_UP, key_up);		}				public function key_down(e:KeyboardEvent):void {			trace ("Key pressed: " + e.charCode);			//trace("Speed Before: " + this.hero.speed);			if(this.hero.get_max_speed() > this.hero.get_speed()) {				this.hero.set_speed(this.hero.get_speed() + 1 );			}						if(e.keyCode == 39) {				if(this.hero.x < 400) 					this.hero.x += this.hero.get_speed();				else					this.desert_map.x -= this.hero.get_speed();			}			if (e.keyCode == 37) {				if(this.hero.x > 50) 					this.hero.x -= this.hero.get_speed();							}						if (e.keyCode == 38) {				this.hero.y -= 4;				this.hero.set_jump(this.hero.get_jump() - 0.5); 			}										trace("Speed After: " + this.hero.get_speed());		}				public function key_up(e:KeyboardEvent):void {			trace ("Key UN-pressed: " + e.charCode);		}								public function spawnEnemy(e:Event){			var randNum = Math.floor(Math.random() * 1000);			if(randNum < spawnRate){				var newEnemy:Enemy = new Enemy(bullets);				newEnemy.x = 560;				newEnemy.y = 350;				enemies.push(newEnemy);				addChild(enemies[enemies.length-1]);				trace(enemies.length);			}		}				public function detectCollision(e:Event){			if(bullets.length > 0){				for(var i:int = 0; i<=bullets.length-1; i++){					for(var j:int = 0; j<=enemies.length; j++){						if(j == enemies.length){							if(bullets[i].x >= hero.x-12 && bullets[i].x <= hero.x + 12){								if(bullets[i].shooter == "ENEMY"){									hero.decreaseLife();									removeChild(bullets[i]);									bullets.splice(i, 1);									trace("Life: " + this.hero.get_life_percentage());								}							}						} else {							if(bullets[i].x >= enemies[j].x - 12 && bullets[i].x <= enemies[j].x + 12){								if(bullets[i].shooter == "HERO"){									removeChild(enemies[j]);									enemies[j].die();									enemies.splice(j, 1);									removeChild(bullets[i]);									bullets.splice(i, 1);								}							}						}					}				}			}		}				public function removeBullet(e:Event){			for(var i:int = 0; i<=bullets.length-1; i++) {				if(bullets[i].x < 0 || bullets[i].x > 550){					removeChild(bullets[i]);					bullets.splice(i, 1);				}			}			}	}}